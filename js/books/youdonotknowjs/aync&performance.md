# 异步和性能

## 异步

1. 分块的程序
2. 事件循环
3. 并行程序
4. 并发
   并发协作: 取得一个长期运行的进程，并将其切割成多个步骤或多个任务，是的其他并发进程有机会将自己的运算插入到事件循环队列中交替运行

5. 任务
   对于任务队列最好的理解就是: 它是挂在事件循环每个 tick 之后的一个队列
6. 语句顺序

7. 小结:
   - js 程序总是至少分为两块: 第一块现在运行; 下一块将来运行，以响应某个事件；
   - 一旦有事件需要运行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个 tick

## 回调

## Promise

1. 什么是 Promise?

   - 未来值
     拒绝值和完成值的 promise 不一样: 完成值总是编程给出的, 而拒绝值, 通常成为拒绝原因, 可能是程序逻辑直接设置的, 也可能是从运行异常隐式得出的值
     Promise 是一种封装和组合未来值的易于复用的机制

   - 完成事件
     Promise 事件

2. 具有 then 方法的鸭子类型
3. Promise 信任问题
4. 链式流
   这种方式可以实现的关键在于以下两个 Promise 固有行为特性: 1.每次你对 Promise 调用 then(...),它都会创建并返回一个新的 Promise, 我们可以将其链接起来 2.不管 then(...)调用的完成回调(第一个参数)返回的值是什么, 它都会被自动设置为被链接 Promise(第一点中的)完成
5. 链式流
6. Promise 模式
7. Promise API 概述

   - new Promise(...)构造器

   ```js
   var p = new Promise(function(resolve, reject) {})
   ```

   - Promise.resolve(...) 和 Promise.reject(...)
   - then(...) 和 catch(...)
   - Promise.all(...) 和 Promise.race(...)

8. Promise 的局限性
   - 顺序错误处理
   - 单一值 1.分裂值 2.展开/传递参数
   - 单决议
   - 惯性

## 生成器

1. 打破完整运行
2. 生成器产生值
3. 异步迭代生成器
4. 生成器+Promise

5. 生成器委托
6. 生成器并发
7. 形实转换程序
8. ES6 之前的生成器

## 性能测试与调优

1. 性能测试
   任何有意义且性能可靠的性能测试都应该基于统计学上合理的实践
2. 环境为王
3. jsPerf.com
4. 写好测试
5. 微性能
6. 尾调用优化
   尾调用就是一个出现在另一个函数“结尾”处的函数调用
   为什么呢 ？ 调用一个新的函数需要额外的一块预留内存来管理调用栈，称为栈帧
7. 小结
