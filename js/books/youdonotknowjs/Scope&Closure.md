# Scope&Closure

## 作用域是什么

1. 编译原理

   - 分词/词法分析(Tokenizing/Lexing)
   - 解析/语法分析(Parsing)
   - 代码生成

2. 理解作用域
   引擎: 从头到尾负责整个 JavaScript 程序的编译和执行过程
   编译器: 负责语法分析及代码生成等
   作用域: 负责收集并维护由所有声明的表示符组成的一系列查询, 并实施一套非常严格的规则, 确定当前执行的代码对这些标识符的访问权限
3. 作用域嵌套

## 词法作用域

简单来说，词法作用域就是定义在词法阶段的作用域；
换句话说，词法作用域是由你在写代码时将变量和块级作用域写在哪里来决定的，因此词法分析器处理代码时会保持作用域不变

1. 词法阶段
2. 欺骗词法

## 函数作用域和块作用域

1.  函数中的作用域
    函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用).
    这种设计方案是非常有用的, 能充分利用 JavaScript 变量可以根据需要改变值类型的'动态'特性
2.  隐藏内部实现
    最小特权原则: 应该最小限度的暴露必要内容而将其他内容都隐藏起来
    规避冲突: 可以避免同名标识符之间的冲突(有以下两种方法可以解决)
    - 全局命名空间
    - 模块管理
3.  函数作用域

    - 匿名和具名
      匿名函数的缺点:

           1. 匿名函数在栈追踪中不会显示出有意义的函数名,使得调试很困难
           2. 如果没有函数名，当函数需要引用自身时只能通过已经过期的 arguments.callee 引用，在事件解绑中也不能进行解绑
           3. 降低了代码的可读性可理解性

    - IIFE(immediately invoked function expression)
      (function(){})()
      应用场景: 1.将自定义名称传进去提高代码的可读性 2.保证 undefined 的正确性 3.倒置代码的运行顺序

4.  块作用域
    - try...catch..的 catch 会创建块级作用域
    - let 会创建块级作用域
    - function
    - const

## 提升

1. 引擎会在解释 JavaScript 之前首先对其进行编译，
2. 第一阶段就是找到所有的声明，并用合适的作用域将它们关联起来（包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理）
3. 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地
4. 函数声明会提升但是函数表达式不会，即使是具名的函数表达式
5. 函数会首先被提升，然后才是变量

## 作用域闭包

什么是闭包 ？ 闭包的优缺点 ？
高程 3：有权访问另外一个函数作用域中的变量的函数

## 对象

1. 什么是属性描述符 ？有几种属性 ？这几种属性分别可以控制什么行为 ？

2. 如何设置对象的属性为不可变 ？如何设置对象为禁止扩展 ？
   同时设置 configable 和 writable 为 false；
   使用 Object.preventExtensions()

3. 如何创建一个密封对象 ？
   Object.seal()

4. 如何创建冻结对象 ？
   Object.freeze()

5. \[\[Get\]\] \[\[Put\]\]

6. Getter 和 Setter Object.defineProperty

7. in 操作符 和 hasOwnProperty propertyIsEnumerable

8. @@iterator

## 混合对象“类”

类/继承描述了一种代码的组织结构形式--一种在软件中对真是世界中问题领域的建模方法
面向对象编程强调的是数据和操作数据的行为本质上是互相关联的

1. 类设计模式

2. javascript 中的类
   类是一种设计模式
   多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是复制

3. 类的机制
   类相当于建造蓝图, 只要有了建造蓝图，建造工人就可以根据蓝图来对房屋进行建造
   类实例是由一个特殊的类方法构造的

4. 类的继承

## 原型

1. \[\[prototype\]\]
   所有普通的\[\[prototype\]\]链最终都会指向哪里 ？
   属性设置的详细过程 ？
   屏蔽是什么 ？ 怎么会产生下层属性不能屏蔽 ？限制屏蔽的情况有哪些 ？
2. 类
   什么是原型继承 ？
   什么是继承 ？ 什么是委托 ？什么是差异继承 ？
   new 的执行过程 ？ new 调用构造函数的副作用 ？
   instanceof ? 只能设置对象和函数之间的关系吗 ？可以判断对象和对象之间的关系吗 ？
   \_\_proto\_\_的实现大致是怎样的 ？

3. 原型继承
4. 对象关联
   - \[\[prototype\]\]机制就是存在于对象中的一个内部链接，它会引用其他对象
     通常来说这个链接的作用是: 如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在\[\[prototype\]\]关联的对象上进行查找...以此类推
   - Obeject.create
     会创建一个对象并把它关联到我们制定的对象, 这样我们就刻意充分发挥\[\[prototype\]\]机制的威力
     ```js
     <!-- Object.create polyfill -->
     if(!Object.create) {
       Object.create = function(o) {
         function F() {}
         F.prototype = o
         return new F()
       }
     }
     ```

## 行为委托

1. 面向委托的设计
   - 类理论
